<!DOCTYPE HTML>
<html>
  <head><style>* {margin: 0; padding: 0;} html,body {width: 100%; height: 100%; overflow: hidden;}</style></head>
  <body>
    <canvas id="c"></canvas>

    <script>
      /* UTILITIES */

      // Determines whether point is in the polygon or not
      // Source: http://stackoverflow.com/a/2922778/1906108
      // Thank you nirg!
      function isInPoly(verts, testx, testy) {
        var nvert = verts.length;
        var i, j, c = 0;
        for (i = 0, j = nvert-1; i < nvert; j = i++) {
          if ( ((verts[i].y>testy) != (verts[j].y>testy)) &&
          (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) )
            c = !c;
        }
        return c;
      }

      function rotatePoint(p, theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);

        return {x: p.x * c - p.y * s, y: p.x * s + p.y * c};
      }

      function triangleCenter(verts) {
        var sum = verts.reduce((acc, val) => ({x: acc.x + val.x, y: acc.y + val.y}), {x: 0, y: 0});

        return {x: sum.x/3, y: sum.y/3};
      }

      /* CODE IS STARTING HERE */
      
      // Initialize canvas
      var canvas = document.getElementById("c");
      var ctx = canvas.getContext("2d");

      canvas.width = canvas.style.width = document.body.offsetWidth;
      canvas.height = canvas.style.height = document.body.offsetHeight;

      // Constants
      const DRAW_OFFSET = 500;

      const GRAPH_SIZE = 300;
      const FILL_SIZE = 100;
      
      const TEXTS = ["STR", "VIT", "LUK", "INT", "DEX", "AGI"];
      const NODE_COUNT = TEXTS.length;

      const ARROW_WIDTH = 25;
      const ARROW_HEIGHT = 50;

      // State
      var START_STAT = 5;
      var STATS = new Array(NODE_COUNT).fill(START_STAT);
      var MAX_STAT = START_STAT * 2 - 1;

      var ARROWS = [];
      var NODES = [];

      var MOUSE_X = 0;
      var MOUSE_Y = 0;

      // Precalculate graph nodes' coordinates
      var step = (Math.PI * 2) / NODE_COUNT;
      var stepOffset = -Math.PI / 2;
      for (var i = 0; i < NODE_COUNT; i++) {
        var cos = Math.cos(step * i + stepOffset);
        var sin = Math.sin(step * i + stepOffset);
        var x = cos * GRAPH_SIZE;
        var y = sin * GRAPH_SIZE; 
        NODES.push({x, y});
      }

      // Precalculate arrows
      stepOffset = Math.PI;
      for (var i = 0; i < NODE_COUNT; i++) {
          var cx = NODES[i].x * 1.1;
          var cy = NODES[i].y * 1.1;
          var rotation = step * i + stepOffset;

          // Create an arrow =)
          var verts = [
            {x: -ARROW_WIDTH, y: -ARROW_HEIGHT / 2}, // Top    left
            {x: ARROW_WIDTH, y: -ARROW_HEIGHT / 2},  // Top    right
            {x: 0, y: ARROW_HEIGHT / 2}              // Bottom center
          ];

          // Let's rotate it then translate it to it's center
          var verts2 = verts.map((v) => {
            var p = rotatePoint(v, rotation);
            return {x: p.x + cx, y: p.y + cy};
          });

          ARROWS.push(verts2);
      }

      function render() {
        ctx.fillStyle = "black";
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Add some offset so we can see the graph clearly
        ctx.translate(DRAW_OFFSET, DRAW_OFFSET);
        
        /* Draw graph */
        ctx.beginPath();
        NODES.forEach((n) => ctx.lineTo(n.x, n.y));
        ctx.closePath();
        ctx.stroke();

        /* Draw arrows + text */
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ARROWS.forEach((arrow, i) => {
          var center = triangleCenter(arrow);
          ctx.fillText(TEXTS[i] + " " + STATS[i], center.x, center.y);

          ctx.beginPath();
          arrow.forEach((n) => ctx.lineTo(n.x, n.y))
          ctx.closePath();
          ctx.stroke();
        });

        /* Filling */
        ctx.fillStyle = "lightblue";

        // Calculate the remaining space between the two points
        var fullGap = GRAPH_SIZE - FILL_SIZE;

        // Draw the filling!
        ctx.beginPath();
        NODES.forEach((p, i) => {
          var ratio = (fullGap * STATS[i] / MAX_STAT) / fullGap;
          ctx.lineTo(p.x * ratio, p.y * ratio);
        });
        ctx.closePath();
        ctx.fill();

        // Let's go back to the start point
        ctx.translate(-DRAW_OFFSET, -DRAW_OFFSET);
        
        // Let's render again!
        window.requestAnimationFrame(render);
      }

      // Mouse movement tracking
      function mousemove(e) {
        MOUSE_X = e.pageX - DRAW_OFFSET;
        MOUSE_Y = e.pageY - DRAW_OFFSET;
      }
      canvas.addEventListener("mousemove", mousemove);

      // Stat logic
      function mouseclick(e) {
        for (var i = 0; i < ARROWS.length; i++) {
          if (isInPoly(ARROWS[i], MOUSE_X, MOUSE_Y)) {
            if (STATS[i] < MAX_STAT) {
              // Increase clicked stat
              STATS[i]++;

              // Decrease opposite stat
              STATS[(i+3)%ARROWS.length]--;
            }
          }
        }
      }
      canvas.addEventListener("click", mouseclick);

      render();
    </script>
  </body>
  </html>